<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">James Rungsawang: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-borpaa/">https://cal-cs184-student.github.io/hw-webpages-borpaa/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw1-borpa">https://github.com/cal-cs184-student/sp25-hw1-borpa</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		I rasterized the triangle using the technique covered in lecture. Basically for each point in the bounding
		box of the triangle, we check if it is inside all three half-planes generated by each edge of the triangle. 
		A point is inside the right half-plane if the cross product of the vector from the tested point to the vector of
		the triangle edge is greater or equal to 0. We have to check the points in both clockwise and counter-clockwise orientation. 
		This is no worse than an algorithm that checks each sample within
		the bounding box of the triangle because it is only checking the points inside the bounding box and then doing simple
		arithmetic operations such as subtraction and multiplication to check if the point's midpoint lies in the triangle.
		<figure>
			<img src="images/part1.png" style="width:50%"/>
			<figcaption>Test4.svg, notice how each pixel is solid colored and the edge isn't too smooth</figcaption>
		</figure>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		To modify my rasterization to implement supersampling, I would check a 2d grid to average for the color of a pixel rather than
		just checking one single point. For each point, we would now expand it to a grid of size sqrt(sample_rate) by 
		sqrt(sample_rate) and check if the center of each cell in this grid is in the triangle to see if we should color it or not.
		Finally, we downscale by making each pixel filled in with the color of the average of that 2d grid. To implement these 2d grids, I used
		the flattened array provided to us called sample_buffer, and would index into it using the pixel row and column and which element
		in the grid we wanted. Supersampling is useful because it antialiases our triangles by bluring out the areas around the ends of the triangle 
		This gives us much smoother transitions and reduces our amount of jaggies as we increase the sampling_rate. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/part2_1.png" width="400px"/>
				  <figcaption>Using sample rate 1.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/part2_4.png" width="400px"/>
				  <figcaption>Using sample rate 4.</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="images/part2_16.png" width="400px"/>
					<figcaption>Using sample rate 16.</figcaption>
				  </td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		I changed cubeman to raise both of his arms diagonally. I achieved this by wrapping the
		object that contains the entire arm with a rotation of 45 degrees for the left arm and -45 on the right arm.
		Then I just had to translate each arm a little bit in the x and y axis to get them aligned into the shoulder again. 
		<figure>
			<img src="images/my_robot.png" style="width:50%"/>
			<figcaption>Robot raising his arms</figcaption>
		</figure>
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates give us a way to interpolate color values for each point on a shape using
		the weighted contributions from each colored vertex based on distance. In our case below, we have three
		vertices colored red, green, and blue and each point will be a weighted colored sum based on its position
		relative to these vertices. The three weights for barycentric coordinates of a point must sum to 1 and 
		tell us how much their corresponding vertex contributes its color to this pixel. 
		<figure>
			<img src="images/triangle.png" style="width:50%"/>
			<figcaption>Interpolated triangle using barycentric coordinates</figcaption>
		</figure>
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is a way for us to determine what color value to give to a pixel
		when we're applying a texture to an object. We need to remap the screen coordinates of the pixels
		to the uv coordinates on the texture. 

		The first method of pixel sampling used was nearest neighbor. This was easily implemented by converting
		the pixel position to the corresponding uv position on the texture and then just taking the color of the closest pixel.

		The better method was bilinear sampling which instead of just taking the closest neighbor, will fill the color
		of the pixel as a linear interpolation of the nearest four points in the texture. The method covered in class
		first gets the color of linearly interpolating the horizontal pairs and then combines those results to interpolate
		vertically.

		Bilinear sampling appears to be much smoother than the nearest neighbor sampling. This is probably 
		because it interpolates on multiple points instead of just taking the nearest neighbor. I was unable
		to see any differences when changing sample rate.

		A large difference will be seen between the two methods when we have a low resolution image, are very zoomed in,
		and are dealing with a very jagged area of pixel coloring where it's a lot more obvious to see the lack
		of smoothness of nearest neighbor sampling.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/bilinear_1.png" width="400px"/>
				  <figcaption>Bilinear sample rate 1</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="images/bilinear_16.png" width="400px"/>
					<figcaption>Bilinear sample rate 16</figcaption>
				  </td>
			  </tr>
			  <tr>
				  <td style="text-align: center;">
					  <img src="images/nearest_1.png" width="400px"/>
					  <figcaption>Nearest sample rate 1</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="images/nearest_16.png" width="400px"/>
					  <figcaption>Nearest sample rate 16</figcaption>
					</td>
			  </tr>
			</table>
		</div>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		</div>
	</body>
</html>
